---
title: "Análisis y modelado"
format: html
editor: visual
---

```{r}

library(readr)
df_airbnb_cleansed <- read_csv("Documents/Bootcamp/PROYECTO FINAL/df_airbnb_cleansed.csv", na = "NA",show_col_types = FALSE)

```

```{r}
problems(df_airbnb_cleansed)

# Error en weekly y monthly price. Salto el error porque no voy a utilizar las columnas.
```

```{r}
summary(df_airbnb_cleansed)
# Resumen del dataframe.
```

```{r}

# Selecciono solo columnas con las que voy a trabajar.

library(dplyr)

df_airbnb_work <- dplyr::select(df_airbnb_cleansed,"ID","HOST_ID","NEIGHBOURHOOD_CLEANSED","ZIPCODE","LATITUDE","LONGITUDE","PROPERTY_TYPE","ROOM_TYPE","ACCOMMODATES","BATHROOMS","BEDROOMS","BEDS","BED_TYPE","PRICE","SECURITY_DEPOSIT","CLEANING_FEE","MINIMUM_NIGHTS","NUMBER_OF_REVIEWS","REVIEW_SCORES_RATING","REVIEW_SCORES_ACCURACY","REVIEW_SCORES_CLEANLINESS","REVIEW_SCORES_CHECKIN","REVIEW_SCORES_COMMUNICATION","REVIEW_SCORES_LOCATION","REVIEW_SCORES_VALUE","CANCELLATION_POLICY","CALCULATED_HOST_LISTINGS_COUNT","REVIEWS_PER_MONTH","PRICE_PER_PERSON","RATIO_BEDS_PERS","RATIO_ROOMS_PERS","RATIO_NVECES_ALQUILADO","SECURITY_DEPOSIT_BOOL")

```

```{r}
# Elimino NA en precio
 df_airbnb_work <- df_airbnb_work[!is.na(df_airbnb_work$PRICE),]

```

```{r}
# Agrupo por ID host y veo que hay host que gestionan muchas viviendas.
library(dplyr)
hosts <- df_airbnb_work |> group_by(HOST_ID) |>  summarise(avg_price=mean(PRICE),
            total_houses= sum(CALCULATED_HOST_LISTINGS_COUNT), madrid_houses = n())
hosts

```

```{r}

# Creo una variable para saber si el host es profesional. Lo considero profesional con 4 casas o más.

df_airbnb_work$PRO_HOST <- (df_airbnb_work$CALCULATED_HOST_LISTINGS_COUNT > 3) == TRUE
```

```{r}

# Veo algún estimador estadístico.

num_viviendas <- nrow(df_airbnb_work)
avg_price <- mean(df_airbnb_work$PRICE)
avg_unit_price <- mean(df_airbnb_work$PRICE_PER_PERSON)

paste("El número total de viviendas es:", num_viviendas)
paste("El precio medio diario de todas las viviendas es:", avg_price)
paste("El precio medio diario por persona de todas las viviendas es:", avg_unit_price)
```

```{r}

# Análisis de la distribución de precio.
ggplot(df_airbnb_work, aes(x=PRICE))+
  geom_histogram(bins=20, color='blue', fill='dark blue')

# Vemos que la mayoría de propiedades tienen un precio inferior o alrededor de 150€ Vemos que hay propiedades con precios muy superiores, que pueden llegar a un máximo de 875€, como vimos en el resumen del dataframe.

# El precio puede depender el número de personas, habitaciones, etc, por lo que vamos a analizar el valor en unitario para eliminar outliers.
C
```

```{r}

ggplot(df_airbnb_work, aes(x=PRICE_PER_PERSON))+
  geom_histogram(bins=20, color='blue', fill='dark blue')

```

```{r}

ggplot(df_under_100, aes(x=PRICE_PER_PERSON))+
  geom_histogram(bins=20, color='blue', fill='dark blue')

```

```{r}
ggplot(df_airbnb_work, aes(x = "", y = PRICE_PER_PERSON)) + geom_boxplot(outlier.colour = "blue") + labs(x = "", y = "")+
  guides(fill = FALSE)  + 
  ggtitle("Analysis price per person")  
 
```

```{r}
df_airbnb_work <- df_airbnb_work |> filter(PRICE_PER_PERSON<40)
```

```{r}
ggplot(df_airbnb_work, aes(x = "", y = PRICE_PER_PERSON)) + geom_boxplot(outlier.colour = "blue") + labs(x = "", y = "")+
  guides(fill = FALSE)  + 
  ggtitle("Analysis price per person")  
 
```


```{r}

# Análisis tipo hospedador.
library(ggplot2)
ggplot(df_airbnb_work) + geom_histogram(aes(PRO_HOST, fill = PRO_HOST), stat = "count") + 
  theme_minimal(base_size=10) + xlab("") + ylab("") +theme(legend.position="none") + 
  ggtitle("Type of host") + scale_x_discrete(labels = c("Professional", "Individual"))

# Hay más viviendas gestionadas por profesionales que por propietarios particulares.

```

```{r}
ggplot(df_airbnb_work, aes(x = PRO_HOST, y = PRICE, fill = PRO_HOST)) + geom_boxplot(outlier.colour = "blue") + labs(x = "", y = "")+ scale_x_discrete(labels = c("Professional", "Individual"))+
  guides(fill = FALSE)  + 
  ggtitle("Price analysis by host type")  
 
```

```{r}

# Análisis tipo de habitación.
library(ggplot2)
ggplot(df_airbnb_work) + geom_histogram(aes(ROOM_TYPE, fill = ROOM_TYPE), stat = "count") + 
  theme_minimal(base_size=10) + xlab("") + ylab("") +theme(legend.position="none") + 
  ggtitle("Type of rooms") + scale_x_discrete(labels = c("Entire home/Apt", "Private room", "Shared room"))


# Como se puede ver, la mayoría de propiedades son "entire home/apartment".

```

```{r}
ggplot(df_airbnb_work, aes(x = ROOM_TYPE, y = PRICE, fill = ROOM_TYPE)) + geom_boxplot(outlier.colour = "blue") + labs(x = "", y = "")+
  guides(fill = FALSE)  + 
  ggtitle("Price analysis by room type")  
 
```

```{r}
# Análisis tipo de propiedad.
group_property <- df_airbnb_work |> group_by(PROPERTY_TYPE) |> 
  summarise(n_houses = n(),avg_price=mean(PRICE),med_price=median(PRICE),avg_rooms = mean(BEDROOMS), avg_unit_rooms = mean(RATIO_ROOMS_PERS),avg_unit_price = mean(PRICE_PER_PERSON),)

print(group_property)

# La mayoría de las casas se concentran en pocos tipos de propiedades.
```

```{r}

# Hay tipo de propiedades con frecuencia muy baja. Cuento por tipo de propiedad y filtro las que tenga más de 50, solo se quedan 6 tipos de propiedades y la mayoría está en apartamento.

group_property <- group_property[group_property$n_houses>50,]
ggplot(group_property, aes(x=PROPERTY_TYPE, y=n_houses))+geom_col(aes(x=PROPERTY_TYPE, fill=PROPERTY_TYPE)) + 
  theme_minimal(base_size=10) + xlab("") + ylab("") +theme(legend.position="none") + 
  ggtitle("Number of houses by property type") + scale_x_discrete(labels = c("Apartment", "B&B", "Condominium", "House", "Loft", "Other"))

```



```{r}
# Análisis precio - tipo de propiedad.
# Decido trabajar solo con tipo de propiedades que tienen más de 50 viviendas (Apartment, Bed & Breakfast, Codominium, House,Loft, Other.)
df_filter_property <- df_airbnb_work |> filter(PROPERTY_TYPE=="APARTMENT"|PROPERTY_TYPE=="BED & BREAKFAST"|PROPERTY_TYPE=="CONDOMINIUM"|PROPERTY_TYPE=="HOUSE"|PROPERTY_TYPE=="LOFT"|PROPERTY_TYPE=="OTHER")
```

```{r}
ggplot(df_filter_property, aes(x = PROPERTY_TYPE, y = PRICE, fill = PROPERTY_TYPE)) + geom_boxplot(outlier.colour = "blue") + labs(x = "", y = "")+ scale_x_discrete(labels = c("Apartment", "B&B", "Condominium","Loft", "House", "Other"))+
  guides(fill = FALSE)  + 
  ggtitle("Price analysis by property type")  
 
# Podemos ver que el precio no varía en función del tipo de propiedad. Todos los tipos son similares.
```

```{r}
# Análisis número de personas por vivienda.
df_filter_property$ACCOMMODATES_FACT <- factor(df_filter_property$ACCOMMODATES)

ggplot(df_filter_property, aes(x = ACCOMMODATES_FACT, y = PRICE, fill = ACCOMMODATES_FACT)) + geom_boxplot(outlier.colour = "blue") + labs(x = "", y = "") +
  guides(fill = FALSE)  + 
  ggtitle("Price analysis by number of accommodates")  

# Se puede ver que el precio es más alto cuando se incrementa el número de personas. 
```

```{r}
# Análisis por barrios.
group_neighbourhood <- df_filter_property |> group_by(NEIGHBOURHOOD_CLEANSED) |> summarise(n_houses = n(),avg_price=mean(PRICE),med_price=median(PRICE),avg_rooms = mean(BEDROOMS), avg_unit_rooms = mean(RATIO_ROOMS_PERS),avg_unit_price = mean(PRICE_PER_PERSON),)

group_neighbourhood[order(-group_neighbourhood$n_houses),]

# Los barrios top 10 en alquileres son Embajadores, Universidad, Palacio, Sol, Justicia, Cortes, Trafalgar, Palos de Moguer, Arguelles, Goya.
```

```{r}
summary(group_neighbourhood)
```

```{r}
# La mayoría de viviendas se conecntran en pocos barrios.
# Filtro barrios en el tercer cuartil para analizar precio por barrio.
group_neigh_3Q <- group_neighbourhood |> filter(n_houses>71)

```

```{r}

#Análisis por barrios.

ggplot(df_neigh_3Q, aes(x = NEIGHBOURHOOD_CLEANSED, y = PRICE, fill = NEIGHBOURHOOD_CLEANSED)) + geom_boxplot(outlier.colour = "blue") + labs(x = "", y = "") +
  guides(fill = FALSE)  + 
  ggtitle("Price analysis by neighbourhood")  +
  coord_flip()         

# Los barrios más caros son Recoletos, Castellana, Jerónimos, Sol y Goya (Top 5)
```

```{r}
#Modelado de regresión lineal para estimar el precio en función de las variables elegidas.
# Medimos la correlación entre variables que creemos que podrían influir en el precio.
est_price <- df_neigh_3Q[,c('PRICE','ZIPCODE','ACCOMMODATES','CANCELLATION_POLICY','REVIEW_SCORES_RATING','SECURITY_DEPOSIT','CLEANING_FEE','MINIMUM_NIGHTS')]

library(GGally)
ggpairs(est_price[,c('PRICE','ZIPCODE','ACCOMMODATES','CANCELLATION_POLICY','REVIEW_SCORES_RATING','SECURITY_DEPOSIT','CLEANING_FEE','MINIMUM_NIGHTS')],
lower = list(continuous = wrap("points", alpha = 0.3,size=0.3,color='blue'))
) 

```

```{r}
# Elegimos variables con alto nivel de correlación. Según el análisis previo podemos suponer que existen múltiples variables que pueden explicar la variación del precio.
model <- lm(data=est_price, formula = PRICE ~ ACCOMMODATES+REVIEW_SCORES_RATING+CANCELLATION_POLICY+SECURITY_DEPOSIT+CLEANING_FEE)
summary(model)
```

```{r}
set.seed(1234)
idx <- sample(1:nrow(df_neigh_3Q), nrow(df_neigh_3Q)*0.7)
df_neigh_3Q.train <-df_neigh_3Q[idx,]
df_neigh_3Q.test <-df_neigh_3Q[-idx,]

```

```{r}
# Calculamos el modelo con el dataset de train.

model_df_neigh_3Q <- lm(data=df_neigh_3Q.train, formula = PRICE ~ ACCOMMODATES+REVIEW_SCORES_RATING+CANCELLATION_POLICY+SECURITY_DEPOSIT+CLEANING_FEE)
summary(model_df_neigh_3Q)
```

```{r}
# Calculamos sus figuras de calidad, tanto en training como en testing:

df_neigh_3Q.train$price_est <- predict(model_df_neigh_3Q, df_neigh_3Q.train)
caret::postResample(pred = df_neigh_3Q.train$price_est, obs=df_neigh_3Q.train$PRICE)
```

```{r}
df_neigh_3Q.test$price_est <- predict(model_df_neigh_3Q, df_neigh_3Q.test)
caret::postResample(pred = df_neigh_3Q.test$price_est, obs=df_neigh_3Q.test$PRICE)
```

Aquí vemos que el R² es parecido en testing y training. Consideramos que ese R² indica que es un modelo aceptable. Para asegurarnos miraremos los residuos.

```{r}
ggplot(df_neigh_3Q.train, aes(x=PRICE, y=PRICE-price_est))+
  geom_point(color='blue', alpha=0.2)+
  geom_hline(yintercept = 0, color='red')+
  ggtitle("Residuos en training")
```

```{r}
ggplot(df_neigh_3Q.train, aes(x=PRICE-price_est))+geom_histogram(color='red', fill='blue') + ggtitle("Residuos en training")
```

```{r}
ggplot(df_neigh_3Q.test, aes(x=PRICE, y=PRICE-price_est))+
  geom_point(color='blue', alpha=0.2)+
  geom_hline(yintercept = 0, color='red')+
  ggtitle("Residuos en testing")
```

```{r}
ggplot(df_neigh_3Q.test, aes(x=PRICE-price_est))+
  geom_histogram(color='red', fill='blue') + ggtitle("Residuos en testing")
```

\`\`\`

Los residuos sigue una distribución normal y los valores medios de los residuos están centrados en 0.
